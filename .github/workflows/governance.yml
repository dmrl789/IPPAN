name: Governance Automation

on:
  issues:
    types: [opened, reopened, labeled, unlabeled]
  pull_request:
    types: [opened, reopened, synchronize, closed, ready_for_review, labeled, unlabeled]
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review, labeled]
  workflow_dispatch:
    inputs:
      mode:
        description: 'Governance operation to run'
        required: true
        default: 'metaagent'
        type: choice
        options:
          - metaagent
          - release
      meta_action:
        description: 'MetaAgent action to perform when mode is metaagent'
        required: false
        default: 'status'
        type: choice
        options:
          - status
          - assign-issues
          - check-conflicts
          - unlock-all
          - reset-quotas
          - restart
      semver_level:
        description: 'Semantic version increment when mode is release'
        required: false
        default: patch
        type: choice
        options:
          - major
          - minor
          - patch
      dry_run:
        description: 'Execute cargo-release in dry-run mode when mode is release'
        required: false
        default: true
        type: boolean
  schedule:
    - cron: '*/15 * * * *'
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write

env:
  META_AGENT_LOG_DIR: '.meta/logs'
  META_LOCK_LABEL: 'locked'
  META_APPROVAL_LABEL: 'metaagent:approved'
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  metaagent-governance:
    name: MetaAgent Governance
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'issues' ||
      github.event_name == 'pull_request' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'metaagent')

    steps:
      - name: ðŸ§­ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ§° Ensure log directory
        run: mkdir -p "${{ env.META_AGENT_LOG_DIR }}"

      - name: ðŸ§  Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo apt-get install -y gh
          cargo install --locked cargo-deny

      - name: ðŸ§  Initialize MetaAgent state
        id: init
        run: |
          echo "MetaAgent initialized at $(date -u)" >> $META_AGENT_LOG_DIR/assignments.log
          if [ ! -f "$META_AGENT_LOG_DIR/agent-registry.json" ]; then
            cat > $META_AGENT_LOG_DIR/agent-registry.json <<'EOF'
{
  "agents": {
    "codex": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "testsprite": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "security-bot": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "infra-bot": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "release-bot": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "docs-bot": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "ui-coach": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "gw-sre": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null},
    "legal": {"active_tasks": 0, "max_tasks": 3, "last_assigned": null}
  },
  "locks": {},
  "conflicts": [],
  "last_quota_reset": "$(date -u +%Y-%m-%d)"
}
EOF
          fi

      # ============================================================
      # 1. ASSIGNMENT LOGIC
      # ============================================================
      - name: ðŸ“‹ Assign Agent Automatically
        if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'labeled')
        run: |
          issue_number=${{ github.event.issue.number }}
          title="${{ github.event.issue.title }}"
          echo "Processing issue #$issue_number - $title"
          labels=$(echo '${{ toJson(github.event.issue.labels) }}' | jq -r '.[].name' | tr '\n' ' ')
          for label in $labels; do
            case $label in
              "codex"|"tests"|"infra"|"docs"|"security"|"ui-ux"|"gateway"|"legal")
                agent_name=$(echo $label | sed 's/ui-ux/ui-coach/' | sed 's/gateway/gw-sre/')
                agent_data=$(jq -r ".agents.$agent_name" $META_AGENT_LOG_DIR/agent-registry.json)
                active_tasks=$(echo $agent_data | jq -r '.active_tasks')
                max_tasks=$(echo $agent_data | jq -r '.max_tasks')
                if [ "$active_tasks" -lt "$max_tasks" ]; then
                  jq --arg agent "$agent_name" --arg issue "$issue_number" \
                    '.agents[$agent].active_tasks += 1 | .agents[$agent].last_assigned = $issue' \
                    $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json
                  echo "$(date -u): Assigned issue #$issue_number to $agent_name" >> $META_AGENT_LOG_DIR/assignments.log
                  gh issue comment $issue_number --body "ðŸ¤– MetaAgent Assignment - Agent: $agent_name, Issue: #$issue_number, Reviewer: ugo-giuliani, ETA: 6h"
                  gh issue add-labels $issue_number "assigned:$agent_name"
                  break
                fi
                ;;
            esac
          done

      # ============================================================
      # 2. CONFLICT DETECTION
      # ============================================================
      - name: âš ï¸ Detect Overlapping PR Scopes
        if: github.event_name == 'pull_request' && github.event.action == 'opened'
        run: |
          pr_number=${{ github.event.pull_request.number }}
          pr_files=$(gh pr view $pr_number --json files --jq '.files[].path')
          touched_crates=$(echo "$pr_files" | grep -o 'crates/[^/]*' | sort -u)
          if [ -n "$touched_crates" ]; then
            for crate in $touched_crates; do
              lock_status=$(jq -r ".locks.$crate" $META_AGENT_LOG_DIR/agent-registry.json)
              if [ "$lock_status" != "null" ] && [ "$lock_status" != "" ]; then
                gh pr add-labels $pr_number "conflict:pending"
                gh issue create --title "Conflict detected: $crate" \
                  --body "**Conflict between PRs on crate:** $crate" \
                  --label "conflict,needs-review"
              else
                jq --arg crate "$crate" --arg pr "$pr_number" \
                  '.locks[$crate] = $pr' \
                  $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json
                gh pr add-labels $pr_number "locked:$crate"
              fi
            done
          fi

      # ============================================================
      # 3. MERGE VALIDATION
      # ============================================================
        - name: âœ… Approve Merge if Checks Pass
          if: github.event_name == 'pull_request' && (github.event.action == 'synchronize' || github.event.action == 'opened' || github.event.action == 'ready_for_review')
          env:
            GITHUB_REPOSITORY: ${{ github.repository }}
          run: |
            pr_number=${{ github.event.pull_request.number }}
            sleep 30
            owner="${GITHUB_REPOSITORY%%/*}"
            repo="${GITHUB_REPOSITORY##*/}"
            ci_status=$(gh api graphql \
              -F owner="$owner" \
              -F name="$repo" \
              -F number="$pr_number" \
              -f query='query($owner:String!, $name:String!, $number:Int!){
                repository(owner:$owner, name:$name){
                  pullRequest(number:$number){
                    statusCheckRollup{ state }
                  }
                }
              }' \
              --jq '.data.repository.pullRequest.statusCheckRollup.state // "PENDING"' \
              2>/dev/null || echo "PENDING")
            if [ -z "$ci_status" ] || [ "${ci_status^^}" = "PENDING" ]; then
              ci_states_json=$(gh pr checks $pr_number --json state --jq '[.[].state]' 2>/dev/null || echo '[]')
              ci_status=$(echo "$ci_states_json" | jq -r '
                if length == 0 then
                  "PENDING"
                elif all(. == "SUCCESS") then
                  "SUCCESS"
                elif any(. == "FAILURE" or . == "ERROR" or . == "CANCELLED") then
                  "FAILURE"
                else
                  "PENDING"
                end
              ')
            fi
            if [ "${ci_status^^}" = "SUCCESS" ]; then
              pr_title="${{ github.event.pull_request.title }}"
              pr_body="${{ github.event.pull_request.body }}"
              if echo "$pr_title" | grep -qE "^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .+"; then
                if echo "$pr_body" | grep -qE "(closes|fixes|resolves) #[0-9]+"; then
                  gh pr add-labels $pr_number "${{ env.META_APPROVAL_LABEL }}"
                  echo "$(date -u): Approved PR #$pr_number" >> $META_AGENT_LOG_DIR/approvals.log
                fi
              fi
            fi
      # ============================================================
      # 4. LOCK MANAGEMENT
      # ============================================================
      - name: ðŸ”“ Unlock crate after merge
        if: github.event_name == 'pull_request' && github.event.action == 'closed'
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          pr_labels=$(gh pr view $pr_number --json labels --jq '.labels[].name' | tr '\n' ' ')
          for label in $pr_labels; do
            if [[ $label == assigned:* ]]; then
              agent_name=$(echo $label | sed 's/assigned://')
              jq --arg agent "$agent_name" \
                '.agents[$agent].active_tasks = (.agents[$agent].active_tasks - 1)' \
                $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json
            fi
          done
          jq --arg pr "$pr_number" \
            'del(.locks | to_entries[] | select(.value == $pr) | .key)' \
            $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json

      # ============================================================
      # 5. MANUAL ACTIONS
      # ============================================================
      - name: ðŸŽ›ï¸ Handle manual MetaAgent actions
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'metaagent'
        env:
          META_ACTION: ${{ github.event.inputs.meta_action || 'status' }}
        run: |
          action="$META_ACTION"
          case "$action" in
            "status")
              jq '.agents, .locks' $META_AGENT_LOG_DIR/agent-registry.json
              ;;
            "unlock-all")
              jq '.locks = {}' $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json
              ;;
            "reset-quotas")
              jq '.agents | map_values(.active_tasks = 0)' $META_AGENT_LOG_DIR/agent-registry.json > tmp.json && mv tmp.json $META_AGENT_LOG_DIR/agent-registry.json
              ;;
          esac

      # ============================================================
      # 6. LOG SYNCHRONIZATION
      # ============================================================
      - name: ðŸª£ Commit Logs to Repo
        if: always()
        run: |
          git config user.name "MetaAgent Bot"
          git config user.email "metaagent@users.noreply.github.com"
          git add $META_AGENT_LOG_DIR || true
          git commit -m "metaagent: sync logs at $(date -u '+%Y-%m-%d %H:%M:%S')" || echo "No new logs"
          git push origin HEAD:metaagent-logs || true

  codex-auto-merge:
    name: Codex Auto Merge
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'pull_request_target' &&
      contains(github.event.pull_request.labels.*.name, 'codex')
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: âš™ï¸ Enable auto-merge for Codex PR
        if: >
          contains(github.event.pull_request.labels.*.name, env.META_APPROVAL_LABEL) &&
          !github.event.pull_request.draft
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          echo "Attempting to enable auto-merge for Codex PR #${PR_NUMBER}"
          gh pr merge "$PR_NUMBER" --merge --auto --delete-branch || \
            echo "Auto-merge criteria not yet satisfied for PR #${PR_NUMBER}"

  release-preflight:
    name: Release Preflight
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.mode == 'release'
    concurrency:
      group: governance-release
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin
            ~/.cargo/registry
            ~/.cargo/git
          key: v20251112-governance-release-${{ runner.os }}-${{ hashFiles('Cargo.lock') }}

      - name: Install cargo-deny
        run: cargo install --locked --force cargo-deny

      - name: Run release checklist
        run: scripts/release-checklist.sh

  release-exec:
    name: Run cargo-release
    runs-on: ubuntu-latest
    needs: release-preflight
    if: >
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.mode == 'release'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin
            ~/.cargo/registry
            ~/.cargo/git
          key: v20251112-governance-release-${{ runner.os }}-${{ hashFiles('Cargo.lock') }}

      - name: Install cargo-release
        run: cargo install --locked --force cargo-release

      - name: Configure git user
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          git config user.name "release-bot"
          git config user.email "release-bot@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}"

      - name: Execute cargo-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ github.event.inputs.dry_run || 'true' }}" = "true" ]; then
            cargo release ${{ github.event.inputs.semver_level || 'patch' }} --workspace --no-confirm
          else
            cargo release ${{ github.event.inputs.semver_level || 'patch' }} --workspace --no-confirm --execute
          fi

  tagged-release:
    name: Publish Tagged Release
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    concurrency:
      group: governance-release
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Publish GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag_name="${GITHUB_REF_NAME}"
          echo "Publishing release for tag ${tag_name}"
          if gh release view "${tag_name}" >/dev/null 2>&1; then
            gh release edit "${tag_name}" --latest
          else
            gh release create "${tag_name}" --verify-tag --generate-notes --latest
          fi
