name: Deploy Unified UI

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      IMAGE_PREFIX: ghcr.io/${{ github.repository }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build Unified UI
        working-directory: apps/unified-ui
        env:
          NEXT_PUBLIC_GATEWAY_URL: ${{ secrets.NEXT_PUBLIC_GATEWAY_URL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          NEXT_PUBLIC_WS_URL: ${{ secrets.NEXT_PUBLIC_WS_URL }}
          NEXT_PUBLIC_ENABLE_FULL_UI: ${{ secrets.NEXT_PUBLIC_ENABLE_FULL_UI }}
        run: |
          npm ci
          npm run build

      - name: Install gateway dependencies
        working-directory: apps/gateway
        run: npm ci

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push container images
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
        run: |
          set -euo pipefail
          IMAGE_PREFIX="${IMAGE_PREFIX,,}"
          docker build -t "$IMAGE_PREFIX/ui:latest" -f apps/unified-ui/Dockerfile apps/unified-ui
          docker build -t "$IMAGE_PREFIX/gateway:latest" apps/gateway
          docker build -t "$IMAGE_PREFIX/node:latest" .
          docker push "$IMAGE_PREFIX/ui:latest"
          docker push "$IMAGE_PREFIX/gateway:latest"
          docker push "$IMAGE_PREFIX/node:latest"

      - name: Sanity-check deploy secrets
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_FINGERPRINT: ${{ secrets.DEPLOY_FINGERPRINT }}
        run: |
          set -euo pipefail
          for v in DEPLOY_HOST DEPLOY_USER DEPLOY_PORT DEPLOY_SSH_KEY DEPLOY_FINGERPRINT; do
            if [ -z "${!v:-}" ]; then
              echo "::error::$v is empty. Add it in Settings → Secrets and variables → Actions."
              exit 1
            fi
          done
          # basic shape checks without leaking secrets
          if [ "${#DEPLOY_SSH_KEY}" -lt 100 ]; then
            echo "::error::DEPLOY_SSH_KEY looks too short. Paste the FULL private key (starts with '-----BEGIN OPENSSH PRIVATE KEY-----')."
            exit 1
          fi

      - name: SSH dry-run (whoami@host)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          port: ${{ secrets.DEPLOY_PORT }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          fingerprint: ${{ secrets.DEPLOY_FINGERPRINT }}
          script: |
            set -e
            whoami
            hostname
            command -v docker >/dev/null || { echo "Docker missing"; exit 1; }
            docker compose version || { echo "Docker compose plugin missing"; exit 1; }

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
          NEXT_PUBLIC_GATEWAY_URL: ${{ secrets.NEXT_PUBLIC_GATEWAY_URL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          NEXT_PUBLIC_WS_URL: ${{ secrets.NEXT_PUBLIC_WS_URL }}
          NEXT_PUBLIC_ENABLE_FULL_UI: ${{ secrets.NEXT_PUBLIC_ENABLE_FULL_UI }}
          TARGET_RPC_URL: ${{ secrets.TARGET_RPC_URL }}
          TARGET_WS_URL: ${{ secrets.TARGET_WS_URL }}
          TARGET_HEALTH_PATH: ${{ secrets.TARGET_HEALTH_PATH }}
          HEALTH_TIMEOUT_MS: ${{ secrets.HEALTH_TIMEOUT_MS }}
          GATEWAY_ALLOWED_ORIGINS: ${{ secrets.GATEWAY_ALLOWED_ORIGINS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          port: ${{ secrets.DEPLOY_PORT }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          fingerprint: ${{ secrets.DEPLOY_FINGERPRINT }}
          envs: IMAGE_PREFIX,NEXT_PUBLIC_GATEWAY_URL,NEXT_PUBLIC_API_BASE_URL,NEXT_PUBLIC_WS_URL,NEXT_PUBLIC_ENABLE_FULL_UI,TARGET_RPC_URL,TARGET_WS_URL,TARGET_HEALTH_PATH,HEALTH_TIMEOUT_MS,GATEWAY_ALLOWED_ORIGINS,GITHUB_TOKEN,GITHUB_ACTOR
          script: |
            set -euo pipefail
            if command -v sudo >/dev/null 2>&1; then
              if sudo -n true 2>/dev/null; then
                SUDO="sudo"
              else
                echo "sudo requires a password; continuing without sudo"
                SUDO=""
              fi
            else
              SUDO=""
            fi

            run_root() {
              if [ -n "$SUDO" ]; then
                sudo "$@"
              else
                "$@"
              fi
            }
            IMAGE_PREFIX="${IMAGE_PREFIX,,}"
            : "${NEXT_PUBLIC_GATEWAY_URL:=https://ui.ippan.org/api}"
            : "${NEXT_PUBLIC_API_BASE_URL:=${NEXT_PUBLIC_GATEWAY_URL}}"
            : "${NEXT_PUBLIC_WS_URL:=wss://ui.ippan.org/ws}"
            : "${NEXT_PUBLIC_ENABLE_FULL_UI:=1}"
            : "${TARGET_RPC_URL:=http://node:8080}"
            : "${TARGET_WS_URL:=ws://node:8080/ws}"
            : "${TARGET_HEALTH_PATH:=/health}"
            : "${HEALTH_TIMEOUT_MS:=5000}"
            : "${GATEWAY_ALLOWED_ORIGINS:=https://ui.ippan.org}"

            APP_DIR=/opt/ippan/ui
            run_root mkdir -p "$APP_DIR"
            run_root chown -R "$USER":"$USER" "$APP_DIR" || true
            cd "$APP_DIR"

            if [ -n "$SUDO" ]; then
              sudo tee docker-compose.yml >/dev/null <<'YML'
            version: "3.8"
            services:
              ui:
                image: ${IMAGE_PREFIX}/ui:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:3000:3000"
              gateway:
                image: ${IMAGE_PREFIX}/gateway:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                depends_on:
                  - node
                ports:
                  - "127.0.0.1:8080:8080"
              node:
                image: ${IMAGE_PREFIX}/node:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:9090:9090"
            networks:
              web:
                driver: bridge
            YML
            else
              cat <<'YML' > docker-compose.yml
            version: "3.8"
            services:
              ui:
                image: ${IMAGE_PREFIX}/ui:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:3000:3000"
              gateway:
                image: ${IMAGE_PREFIX}/gateway:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                depends_on:
                  - node
                ports:
                  - "127.0.0.1:8080:8080"
              node:
                image: ${IMAGE_PREFIX}/node:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:9090:9090"
            networks:
              web:
                driver: bridge
            YML

            if [ -n "$SUDO" ]; then
              sudo tee .env >/dev/null <<'ENV'
            NODE_ENV=production
            NEXT_PUBLIC_GATEWAY_URL=${NEXT_PUBLIC_GATEWAY_URL}
            NEXT_PUBLIC_API_BASE_URL=${NEXT_PUBLIC_API_BASE_URL}
            NEXT_PUBLIC_WS_URL=${NEXT_PUBLIC_WS_URL}
            NEXT_PUBLIC_ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            TARGET_RPC_URL=${TARGET_RPC_URL}
            TARGET_WS_URL=${TARGET_WS_URL}
            TARGET_HEALTH_PATH=${TARGET_HEALTH_PATH}
            HEALTH_TIMEOUT_MS=${HEALTH_TIMEOUT_MS}
            ALLOWED_ORIGINS=${GATEWAY_ALLOWED_ORIGINS}
            ENV
            else
              cat <<'ENV' > .env
            NODE_ENV=production
            NEXT_PUBLIC_GATEWAY_URL=${NEXT_PUBLIC_GATEWAY_URL}
            NEXT_PUBLIC_API_BASE_URL=${NEXT_PUBLIC_API_BASE_URL}
            NEXT_PUBLIC_WS_URL=${NEXT_PUBLIC_WS_URL}
            NEXT_PUBLIC_ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            TARGET_RPC_URL=${TARGET_RPC_URL}
            TARGET_WS_URL=${TARGET_WS_URL}
            TARGET_HEALTH_PATH=${TARGET_HEALTH_PATH}
            HEALTH_TIMEOUT_MS=${HEALTH_TIMEOUT_MS}
            ALLOWED_ORIGINS=${GATEWAY_ALLOWED_ORIGINS}
            ENV

            fi

            run_root mkdir -p /etc/nginx/sites-available /etc/nginx/sites-enabled

            if [ -n "$SUDO" ]; then
              sudo tee /etc/nginx/sites-available/ui.ippan.org >/dev/null <<'NGINX'
            server {
              listen 80;
              server_name ui.ippan.org;
              return 301 https://$host$request_uri;
            }

            server {
              listen 443 ssl http2;
              server_name ui.ippan.org;

              ssl_certificate     /etc/letsencrypt/live/ui.ippan.org/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/ui.ippan.org/privkey.pem;

              location / {
                proxy_pass http://127.0.0.1:3000;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /api/ {
                proxy_pass http://127.0.0.1:8080/;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /ws/ {
                proxy_pass http://127.0.0.1:8080/ws/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
                proxy_set_header Host $host;
              }
            }
            NGINX
            else
              cat <<'NGINX' > /etc/nginx/sites-available/ui.ippan.org
            server {
              listen 80;
              server_name ui.ippan.org;
              return 301 https://$host$request_uri;
            }

            server {
              listen 443 ssl http2;
              server_name ui.ippan.org;

              ssl_certificate     /etc/letsencrypt/live/ui.ippan.org/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/ui.ippan.org/privkey.pem;

              location / {
                proxy_pass http://127.0.0.1:3000;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /api/ {
                proxy_pass http://127.0.0.1:8080/;
                proxy_set_header Host $host;
                proxy_set_header X-Forwarded-For $remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /ws/ {
                proxy_pass http://127.0.0.1:8080/ws/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
                proxy_set_header Host $host;
              }
            }
            NGINX

            fi

            run_root ln -sf /etc/nginx/sites-available/ui.ippan.org /etc/nginx/sites-enabled/ui.ippan.org

            if docker compose version >/dev/null 2>&1; then
              DC="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DC="docker-compose"
            else
              echo "Installing docker-compose v2..."
              run_root curl -fsSL "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-$(uname -s)-$(uname -m)" \
                -o /usr/local/bin/docker-compose
              run_root chmod +x /usr/local/bin/docker-compose
              DC="docker-compose"
            fi

            if [ -n "${GITHUB_TOKEN:-}" ]; then
              printf '%s\n' "$GITHUB_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
            fi
            $DC pull
            $DC up -d
            docker system prune -f

            run_root nginx -t
            if ! run_root systemctl reload nginx; then
              echo "systemctl reload failed; attempting nginx -s reload"
              run_root nginx -s reload
            fi
