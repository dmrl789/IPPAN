name: Deploy Unified UI

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-unified-ui-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      IMAGE_PREFIX: ghcr.io/${{ github.repository }}
      UI_HOST_PORT: 3001
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build Unified UI
        working-directory: apps/unified-ui
        env:
          NEXT_PUBLIC_GATEWAY_URL: ${{ secrets.NEXT_PUBLIC_GATEWAY_URL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          NEXT_PUBLIC_WS_URL: ${{ secrets.NEXT_PUBLIC_WS_URL }}
          NEXT_PUBLIC_ENABLE_FULL_UI: ${{ secrets.NEXT_PUBLIC_ENABLE_FULL_UI }}
        run: |
          set -euo pipefail
          npm ci
          npm run build

      - name: Install gateway dependencies
        working-directory: apps/gateway
        run: |
          set -euo pipefail
          npm ci

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push container images
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
          UI_HOST_PORT: ${{ env.UI_HOST_PORT }}
        run: |
          set -euo pipefail
          IMAGE_PREFIX="${IMAGE_PREFIX,,}"
          docker build -t "$IMAGE_PREFIX/ui:latest" -f apps/unified-ui/Dockerfile apps/unified-ui
          docker build -t "$IMAGE_PREFIX/gateway:latest" apps/gateway
          docker build -t "$IMAGE_PREFIX/node:latest" .
          docker push "$IMAGE_PREFIX/ui:latest"
          docker push "$IMAGE_PREFIX/gateway:latest"
          docker push "$IMAGE_PREFIX/node:latest"

      - name: Sanity-check deploy secrets
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_FINGERPRINT: ${{ secrets.DEPLOY_FINGERPRINT }}
        run: |
          set -euo pipefail
          for v in DEPLOY_HOST DEPLOY_USER DEPLOY_PORT DEPLOY_SSH_KEY DEPLOY_FINGERPRINT; do
            if [ -z "${!v:-}" ]; then
              echo "::error::$v is empty. Add it in Settings → Secrets and variables → Actions."
              exit 1
            fi
          done
          if [ "${#DEPLOY_SSH_KEY}" -lt 100 ]; then
            echo "::error::DEPLOY_SSH_KEY looks too short. Paste the FULL private key (starts with '-----BEGIN OPENSSH PRIVATE KEY-----')."
            exit 1
          fi

      - name: SSH dry-run (whoami@host)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          port: ${{ secrets.DEPLOY_PORT }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          fingerprint: ${{ secrets.DEPLOY_FINGERPRINT }}
          script: |
            set -e
            whoami
            hostname
            command -v docker >/dev/null || { echo "Docker missing"; exit 1; }
            docker compose version || { echo "Docker compose plugin missing"; exit 1; }

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_PREFIX: ${{ env.IMAGE_PREFIX }}
          NEXT_PUBLIC_GATEWAY_URL: ${{ secrets.NEXT_PUBLIC_GATEWAY_URL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          NEXT_PUBLIC_WS_URL: ${{ secrets.NEXT_PUBLIC_WS_URL }}
          NEXT_PUBLIC_ENABLE_FULL_UI: ${{ secrets.NEXT_PUBLIC_ENABLE_FULL_UI }}
          TARGET_RPC_URL: ${{ secrets.TARGET_RPC_URL }}
          TARGET_WS_URL: ${{ secrets.TARGET_WS_URL }}
          TARGET_HEALTH_PATH: ${{ secrets.TARGET_HEALTH_PATH }}
          HEALTH_TIMEOUT_MS: ${{ secrets.HEALTH_TIMEOUT_MS }}
          GATEWAY_ALLOWED_ORIGINS: ${{ secrets.GATEWAY_ALLOWED_ORIGINS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          DEPLOY_APP_DIR: ${{ secrets.DEPLOY_APP_DIR }}
          UI_HOST_PORT: ${{ env.UI_HOST_PORT }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          port: ${{ secrets.DEPLOY_PORT }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          fingerprint: ${{ secrets.DEPLOY_FINGERPRINT }}
          envs: IMAGE_PREFIX,NEXT_PUBLIC_GATEWAY_URL,NEXT_PUBLIC_API_BASE_URL,NEXT_PUBLIC_WS_URL,NEXT_PUBLIC_ENABLE_FULL_UI,TARGET_RPC_URL,TARGET_WS_URL,TARGET_HEALTH_PATH,HEALTH_TIMEOUT_MS,GATEWAY_ALLOWED_ORIGINS,GITHUB_TOKEN,GITHUB_ACTOR,DEPLOY_APP_DIR,UI_HOST_PORT
          script: |
            set -euo pipefail
            if command -v sudo >/dev/null 2>&1; then
              if sudo -n true 2>/dev/null; then
                SUDO="sudo"
              else
                echo "sudo requires a password; continuing without sudo"
                SUDO=""
              fi
            else
              SUDO=""
            fi

            run_root() {
              if [ -n "$SUDO" ]; then
                sudo "$@"
              else
                "$@"
              fi
            }

            IMAGE_PREFIX="${IMAGE_PREFIX,,}"
            : "${UI_HOST_PORT:=3001}"
            : "${NEXT_PUBLIC_GATEWAY_URL:=https://ui.ippan.org/api}"
            : "${NEXT_PUBLIC_API_BASE_URL:=${NEXT_PUBLIC_GATEWAY_URL}}"
            : "${NEXT_PUBLIC_WS_URL:=wss://ui.ippan.org/ws}"
            : "${NEXT_PUBLIC_ENABLE_FULL_UI:=1}"
            : "${TARGET_RPC_URL:=http://node:8080}"
            : "${TARGET_WS_URL:=ws://node:8080/ws}"
            : "${TARGET_HEALTH_PATH:=/health}"
            : "${HEALTH_TIMEOUT_MS:=5000}"
            : "${GATEWAY_ALLOWED_ORIGINS:=https://ui.ippan.org}"

            DEFAULT_APP_DIR="$HOME/apps/ippan-ui"
            REQUESTED_APP_DIR="${DEPLOY_APP_DIR:-$DEFAULT_APP_DIR}"

            ensure_dir() {
              local dir="$1"
              if mkdir -p "$dir" 2>/dev/null; then
                return 0
              fi
              if [ -n "$SUDO" ]; then
                run_root mkdir -p "$dir"
                run_root chown -R "$USER":"$USER" "$dir" || true
                return 0
              fi
              return 1
            }

            if ensure_dir "$REQUESTED_APP_DIR"; then
              APP_DIR="$REQUESTED_APP_DIR"
            else
              echo "::warning::Cannot create '$REQUESTED_APP_DIR' without sudo; falling back to '$DEFAULT_APP_DIR'"
              APP_DIR="$DEFAULT_APP_DIR"
              ensure_dir "$APP_DIR"
            fi

            ensure_dir "$APP_DIR/releases"
            ensure_dir "$APP_DIR/shared"
            cd "$APP_DIR"

            cat <<'YML' > docker-compose.yml
            version: "3.8"
            services:
              ui:
                image: ${IMAGE_PREFIX}/ui:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:${UI_HOST_PORT:-3001}:3000"
              gateway:
                image: ${IMAGE_PREFIX}/gateway:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                depends_on:
                  - node
                ports:
                  - "127.0.0.1:8080:8080"
              node:
                image: ${IMAGE_PREFIX}/node:latest
                env_file:
                  - .env
                restart: unless-stopped
                networks:
                  - web
                ports:
                  - "127.0.0.1:9090:9090"
            networks:
              web:
                driver: bridge
            YML

            cat <<ENV > .env
            NODE_ENV=production
            NEXT_PUBLIC_GATEWAY_URL=${NEXT_PUBLIC_GATEWAY_URL}
            NEXT_PUBLIC_API_BASE_URL=${NEXT_PUBLIC_API_BASE_URL}
            NEXT_PUBLIC_WS_URL=${NEXT_PUBLIC_WS_URL}
            NEXT_PUBLIC_ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            ENABLE_FULL_UI=${NEXT_PUBLIC_ENABLE_FULL_UI}
            TARGET_RPC_URL=${TARGET_RPC_URL}
            TARGET_WS_URL=${TARGET_WS_URL}
            TARGET_HEALTH_PATH=${TARGET_HEALTH_PATH}
            HEALTH_TIMEOUT_MS=${HEALTH_TIMEOUT_MS}
            ALLOWED_ORIGINS=${GATEWAY_ALLOWED_ORIGINS}
            ENV

            if [ -n "$SUDO" ]; then
              run_root mkdir -p /etc/nginx/sites-available /etc/nginx/sites-enabled
              cat <<NGINX | sudo tee /etc/nginx/sites-available/ui.ippan.org >/dev/null
            server {
              listen 80;
              server_name ui.ippan.org;
              return 301 https://\$host\$request_uri;
            }

            server {
              listen 443 ssl http2;
              server_name ui.ippan.org;

              ssl_certificate     /etc/letsencrypt/live/ui.ippan.org/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/ui.ippan.org/privkey.pem;

              location / {
                proxy_pass http://127.0.0.1:${UI_HOST_PORT};
                proxy_set_header Host \$host;
                proxy_set_header X-Forwarded-For \$remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /api/ {
                proxy_pass http://127.0.0.1:8080/;
                proxy_set_header Host \$host;
                proxy_set_header X-Forwarded-For \$remote_addr;
                proxy_set_header X-Forwarded-Proto https;
                proxy_read_timeout 300;
              }

              location /ws/ {
                proxy_pass http://127.0.0.1:8080/ws/;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection "upgrade";
                proxy_set_header Host \$host;
              }
            }
            NGINX
              run_root ln -sf /etc/nginx/sites-available/ui.ippan.org /etc/nginx/sites-enabled/ui.ippan.org
            else
              echo "sudo unavailable; skipping nginx configuration"
            fi

            if docker compose version >/dev/null 2>&1; then
              DC="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DC="docker-compose"
            else
              if [ -n "$SUDO" ]; then
                echo "Installing docker-compose v2 with sudo..."
                run_root curl -fsSL "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-$(uname -s)-$(uname -m)" \
                  -o /usr/local/bin/docker-compose
                run_root chmod +x /usr/local/bin/docker-compose
                DC="docker-compose"
              else
                echo "Installing docker compose plugin in user directory..."
                mkdir -p "$HOME/.docker/cli-plugins"
                curl -fsSL "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-$(uname -s)-$(uname -m)" \
                  -o "$HOME/.docker/cli-plugins/docker-compose"
                chmod +x "$HOME/.docker/cli-plugins/docker-compose"
                DC="docker compose"
              fi
            fi

            if [ -n "${GITHUB_TOKEN:-}" ]; then
              printf '%s\n' "$GITHUB_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
            fi

            $DC down --remove-orphans || true

            # Best-effort cleanup of any stray UI container names from previous runs
            remove_container() {
              local name="$1"
              if [ -n "$SUDO" ]; then
                run_root docker rm -f "$name" 2>/dev/null || true
              else
                docker rm -f "$name" 2>/dev/null || true
              fi
            }
            remove_container "ippan-ui-ui-1"

            free_port() {
              local port="$1"
              local pids=""
              if command -v fuser >/dev/null 2>&1; then
                if [ -n "$SUDO" ]; then
                  run_root fuser -k "${port}/tcp" 2>/dev/null || true
                else
                  fuser -k "${port}/tcp" 2>/dev/null || true
                fi
              elif command -v lsof >/dev/null 2>&1; then
                if [ -n "$SUDO" ]; then
                  pids="$(run_root lsof -ti:"$port" 2>/dev/null || true)"
                  if [ -n "$pids" ]; then
                    run_root kill -9 $pids 2>/dev/null || true
                  fi
                else
                  pids="$(lsof -ti:"$port" 2>/dev/null || true)"
                  if [ -n "$pids" ]; then
                    kill -9 $pids 2>/dev/null || true
                  fi
                fi
              else
                echo "::warning::Neither fuser nor lsof found; skipping port $port cleanup"
              fi
            }

            free_port "$UI_HOST_PORT"

            $DC pull
            $DC up -d --force-recreate
            docker system prune -f

            if [ -n "$SUDO" ]; then
              run_root nginx -t
              if ! run_root systemctl reload nginx; then
                echo "systemctl reload failed; attempting nginx -s reload"
                run_root nginx -s reload
              fi
            fi
